{
    "sourceFile": "crypto/equihash.h",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1667757836020,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1667757861080,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -301,10 +301,11 @@\n     } else if (n == 96 && k == 3) {                      \\\r\n         ret = Eh96_3.IsValidSolution(base_state, soln);  \\\r\n     } else if (n == 48 && k == 5) {                      \\\r\n         ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n-        else if (n == 48 && k == 5) {                      \\\r\n-        ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n+    }\r\n+      else if (n == 48 && k == 5) {                      \\\r\n+        ret = Eh48_5.IsValidSolution(base_state, soln);  \\    \r\n     } else {                                             \\\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\"); \\\r\n     }\r\n \r\n"
                },
                {
                    "date": 1667757916926,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -301,11 +301,10 @@\n     } else if (n == 96 && k == 3) {                      \\\r\n         ret = Eh96_3.IsValidSolution(base_state, soln);  \\\r\n     } else if (n == 48 && k == 5) {                      \\\r\n         ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n-    }\r\n-      else if (n == 48 && k == 5) {                      \\\r\n-        ret = Eh48_5.IsValidSolution(base_state, soln);  \\    \r\n+    } else if (n == 184 && k == 7) {                     \\\r\n+        ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n     } else {                                             \\\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\"); \\\r\n     }\r\n \r\n"
                },
                {
                    "date": 1667757933129,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,8 +273,11 @@\n     } else if (n == 96 && k == 3) {\r\n         return Eh96_3.OptimisedSolve(base_state, validBlock, cancelled);\r\n     } else if (n == 48 && k == 5) {\r\n         return Eh48_5.OptimisedSolve(base_state, validBlock, cancelled);\r\n+        else if (n == 192 && k == 7) {\r\n+        return Eh192_7.OptimisedSolve(base_state, validBlock, cancelled);\r\n+    }\r\n     } else {\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\");\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1667757946201,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,11 +273,10 @@\n     } else if (n == 96 && k == 3) {\r\n         return Eh96_3.OptimisedSolve(base_state, validBlock, cancelled);\r\n     } else if (n == 48 && k == 5) {\r\n         return Eh48_5.OptimisedSolve(base_state, validBlock, cancelled);\r\n-        else if (n == 192 && k == 7) {\r\n+    }  else if (n == 192 && k == 7) {\r\n         return Eh192_7.OptimisedSolve(base_state, validBlock, cancelled);\r\n-    }\r\n     } else {\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\");\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1667757981676,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -273,10 +273,10 @@\n     } else if (n == 96 && k == 3) {\r\n         return Eh96_3.OptimisedSolve(base_state, validBlock, cancelled);\r\n     } else if (n == 48 && k == 5) {\r\n         return Eh48_5.OptimisedSolve(base_state, validBlock, cancelled);\r\n-    }  else if (n == 192 && k == 7) {\r\n-        return Eh192_7.OptimisedSolve(base_state, validBlock, cancelled);\r\n+    }  else if (n == 184 && k == 7) {\r\n+        return Eh184_7.OptimisedSolve(base_state, validBlock, cancelled);\r\n     } else {\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\");\r\n     }\r\n }\r\n@@ -304,9 +304,9 @@\n         ret = Eh96_3.IsValidSolution(base_state, soln);  \\\r\n     } else if (n == 48 && k == 5) {                      \\\r\n         ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n     } else if (n == 184 && k == 7) {                     \\\r\n-        ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n+        ret = Eh184_7.IsValidSolution(base_state, soln);  \\\r\n     } else {                                             \\\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\"); \\\r\n     }\r\n \r\n"
                },
                {
                    "date": 1667758018412,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -243,8 +243,10 @@\n     } else if (n == 96 && k == 3) {\r\n         return Eh96_3.BasicSolve(base_state, validBlock, cancelled);\r\n     } else if (n == 48 && k == 5) {\r\n         return Eh48_5.BasicSolve(base_state, validBlock, cancelled);\r\n+    } else if (n == 184 && k == 7) {\r\n+        return Eh184_7.BasicSolve(base_state, validBlock, cancelled);\r\n     } else {\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\");\r\n     }\r\n }\r\n"
                },
                {
                    "date": 1667758043624,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -220,8 +220,10 @@\n     } else if (n == 96 && k == 3) {          \\\r\n         Eh96_3.InitialiseState(base_state, personalizationString);  \\\r\n     } else if (n == 48 && k == 5) {          \\\r\n         Eh48_5.InitialiseState(base_state, personalizationString);  \\\r\n+    } else if (n == 184 && k == 7) {          \\\r\n+        Eh184_7.InitialiseState(base_state, personalizationString);  \\\r\n     } else {                                 \\\r\n         throw std::invalid_argument(\"Unsupported Equihash parameters\"); \\\r\n     }\r\n \r\n"
                },
                {
                    "date": 1667758128962,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -203,10 +203,10 @@\n static Equihash<48,5> Eh48_5;\r\n static Equihash<144,5> Eh144_5;\r\n static Equihash<192,7> Eh192_7;\r\n static Equihash<125,4> Eh125_4;\r\n+static Equihash<184,7> Eh184_7;\r\n \r\n-\r\n #define EhInitialiseState(n, k, base_state, personalizationString)  \\\r\n     if (n == 200 && k == 9) {\t\t\t\t \\\r\n         Eh200_9.InitialiseState(base_state, personalizationString); \\\r\n     } else if (n == 125 && k == 4) {         \\\r\n"
                }
            ],
            "date": 1667757836020,
            "name": "Commit-0",
            "content": "// Copyright (c) 2016 Jack Grigg\r\n// Copyright (c) 2016 The Zcash developers\r\n// Copyright (c) 2017-2018 The LitecoinZ developers\r\n// Copyright (c) 2018 The s-nomp developers\r\n// Distributed under the MIT software license, see the accompanying\r\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n\r\n#ifndef BITCOIN_EQUIHASH_H\r\n#define BITCOIN_EQUIHASH_H\r\n\r\n#include \"crypto/sha256.h\"\r\n#include \"utilstrencodings.h\"\r\n\r\n#include \"sodium.h\"\r\n\r\n#include <cstring>\r\n#include <stdexcept>\r\n#include <exception>\r\n#include <functional>\r\n#include <memory>\r\n#include <set>\r\n#include <vector>\r\n\r\n#include <boost/static_assert.hpp>\r\n\r\ntypedef crypto_generichash_blake2b_state eh_HashState;\r\ntypedef uint32_t eh_index;\r\ntypedef uint8_t eh_trunc;\r\n\r\nvoid ExpandArray(const unsigned char* in, size_t in_len,\r\n                 unsigned char* out, size_t out_len,\r\n                 size_t bit_len, size_t byte_pad=0);\r\nvoid CompressArray(const unsigned char* in, size_t in_len,\r\n                   unsigned char* out, size_t out_len,\r\n                   size_t bit_len, size_t byte_pad=0);\r\n\r\neh_index ArrayToEhIndex(const unsigned char* array);\r\neh_trunc TruncateIndex(const eh_index i, const unsigned int ilen);\r\n\r\nstd::vector<eh_index> GetIndicesFromMinimal(std::vector<unsigned char> minimal,\r\n                                            size_t cBitLen);\r\nstd::vector<unsigned char> GetMinimalFromIndices(std::vector<eh_index> indices,\r\n                                                 size_t cBitLen);\r\n\r\ntemplate<size_t WIDTH>\r\nclass StepRow\r\n{\r\n    template<size_t W>\r\n    friend class StepRow;\r\n    friend class CompareSR;\r\n\r\nprotected:\r\n    unsigned char hash[WIDTH];\r\n\r\npublic:\r\n    StepRow(const unsigned char* hashIn, size_t hInLen,\r\n            size_t hLen, size_t cBitLen);\r\n    ~StepRow() { }\r\n\r\n    template<size_t W>\r\n    StepRow(const StepRow<W>& a);\r\n\r\n    bool IsZero(size_t len);\r\n    std::string GetHex(size_t len) { return HexStr(hash, hash+len); }\r\n\r\n    template<size_t W>\r\n    friend bool HasCollision(StepRow<W>& a, StepRow<W>& b, int l);\r\n};\r\n\r\nclass CompareSR\r\n{\r\nprivate:\r\n    size_t len;\r\n\r\npublic:\r\n    CompareSR(size_t l) : len {l} { }\r\n\r\n    template<size_t W>\r\n    inline bool operator()(const StepRow<W>& a, const StepRow<W>& b) { return memcmp(a.hash, b.hash, len) < 0; }\r\n};\r\n\r\ntemplate<size_t WIDTH>\r\nbool HasCollision(StepRow<WIDTH>& a, StepRow<WIDTH>& b, int l);\r\n\r\ntemplate<size_t WIDTH>\r\nclass FullStepRow : public StepRow<WIDTH>\r\n{\r\n    template<size_t W>\r\n    friend class FullStepRow;\r\n\r\n    using StepRow<WIDTH>::hash;\r\n\r\npublic:\r\n    FullStepRow(const unsigned char* hashIn, size_t hInLen,\r\n                size_t hLen, size_t cBitLen, eh_index i);\r\n    ~FullStepRow() { }\r\n\r\n    FullStepRow(const FullStepRow<WIDTH>& a) : StepRow<WIDTH> {a} { }\r\n    template<size_t W>\r\n    FullStepRow(const FullStepRow<W>& a, const FullStepRow<W>& b, size_t len, size_t lenIndices, int trim);\r\n    FullStepRow& operator=(const FullStepRow<WIDTH>& a);\r\n\r\n    inline bool IndicesBefore(const FullStepRow<WIDTH>& a, size_t len, size_t lenIndices) const { return memcmp(hash+len, a.hash+len, lenIndices) < 0; }\r\n    std::vector<unsigned char> GetIndices(size_t len, size_t lenIndices,\r\n                                          size_t cBitLen) const;\r\n\r\n    template<size_t W>\r\n    friend bool DistinctIndices(const FullStepRow<W>& a, const FullStepRow<W>& b,\r\n                                size_t len, size_t lenIndices);\r\n    template<size_t W>\r\n    friend bool IsValidBranch(const FullStepRow<W>& a, const size_t len, const unsigned int ilen, const eh_trunc t);\r\n};\r\n\r\ntemplate<size_t WIDTH>\r\nclass TruncatedStepRow : public StepRow<WIDTH>\r\n{\r\n    template<size_t W>\r\n    friend class TruncatedStepRow;\r\n\r\n    using StepRow<WIDTH>::hash;\r\n\r\npublic:\r\n    TruncatedStepRow(const unsigned char* hashIn, size_t hInLen,\r\n                     size_t hLen, size_t cBitLen,\r\n                     eh_index i, unsigned int ilen);\r\n    ~TruncatedStepRow() { }\r\n\r\n    TruncatedStepRow(const TruncatedStepRow<WIDTH>& a) : StepRow<WIDTH> {a} { }\r\n    template<size_t W>\r\n    TruncatedStepRow(const TruncatedStepRow<W>& a, const TruncatedStepRow<W>& b, size_t len, size_t lenIndices, int trim);\r\n    TruncatedStepRow& operator=(const TruncatedStepRow<WIDTH>& a);\r\n\r\n    inline bool IndicesBefore(const TruncatedStepRow<WIDTH>& a, size_t len, size_t lenIndices) const { return memcmp(hash+len, a.hash+len, lenIndices) < 0; }\r\n    std::shared_ptr<eh_trunc> GetTruncatedIndices(size_t len, size_t lenIndices) const;\r\n};\r\n\r\nenum EhSolverCancelCheck\r\n{\r\n    ListGeneration,\r\n    ListSorting,\r\n    ListColliding,\r\n    RoundEnd,\r\n    FinalSorting,\r\n    FinalColliding,\r\n    PartialGeneration,\r\n    PartialSorting,\r\n    PartialSubtreeEnd,\r\n    PartialIndexEnd,\r\n    PartialEnd\r\n};\r\n\r\nclass EhSolverCancelledException : public std::exception\r\n{\r\n    virtual const char* what() const throw() {\r\n        return \"Equihash solver was cancelled\";\r\n    }\r\n};\r\n\r\ninline constexpr const size_t max(const size_t A, const size_t B) { return A > B ? A : B; }\r\n\r\ninline constexpr size_t equihash_solution_size(unsigned int N, unsigned int K) {\r\n    return (1 << K)*(N/(K+1)+1)/8;\r\n}\r\n\r\ntemplate<unsigned int N, unsigned int K>\r\nclass Equihash\r\n{\r\nprivate:\r\n    BOOST_STATIC_ASSERT(K < N);\r\n    BOOST_STATIC_ASSERT((N/(K+1)) + 1 < 8*sizeof(eh_index));\r\n\r\npublic:\r\n    enum : size_t { IndicesPerHashOutput=512/N };\r\n    enum : size_t { HashOutput=IndicesPerHashOutput*((N+7)/8) };\r\n    enum : size_t { CollisionBitLength=N/(K+1) };\r\n    enum : size_t { CollisionByteLength=(CollisionBitLength+7)/8 };\r\n    enum : size_t { HashLength=(K+1)*CollisionByteLength };\r\n    enum : size_t { FullWidth=2*CollisionByteLength+sizeof(eh_index)*(1 << (K-1)) };\r\n    enum : size_t { FinalFullWidth=2*CollisionByteLength+sizeof(eh_index)*(1 << (K)) };\r\n    enum : size_t { TruncatedWidth=max(HashLength+sizeof(eh_trunc), 2*CollisionByteLength+sizeof(eh_trunc)*(1 << (K-1))) };\r\n    enum : size_t { FinalTruncatedWidth=max(HashLength+sizeof(eh_trunc), 2*CollisionByteLength+sizeof(eh_trunc)*(1 << (K))) };\r\n    enum : size_t { SolutionWidth=(1 << K)*(CollisionBitLength+1)/8 };\r\n\r\n    Equihash() { }\r\n\r\n    int InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\n    bool BasicSolve(const eh_HashState& base_state,\r\n                    const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                    const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n    bool OptimisedSolve(const eh_HashState& base_state,\r\n                        const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                        const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\n    bool IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n};\r\n\r\n#include \"equihash.tcc\"\r\n\r\nstatic Equihash<96,3> Eh96_3;\r\nstatic Equihash<200,9> Eh200_9;\r\nstatic Equihash<96,5> Eh96_5;\r\nstatic Equihash<48,5> Eh48_5;\r\nstatic Equihash<144,5> Eh144_5;\r\nstatic Equihash<192,7> Eh192_7;\r\nstatic Equihash<125,4> Eh125_4;\r\n\r\n\r\n#define EhInitialiseState(n, k, base_state, personalizationString)  \\\r\n    if (n == 200 && k == 9) {\t\t\t\t \\\r\n        Eh200_9.InitialiseState(base_state, personalizationString); \\\r\n    } else if (n == 125 && k == 4) {         \\\r\n        Eh125_4.InitialiseState(base_state, personalizationString); \\\r\n    } else if (n == 144 && k == 5) {         \\\r\n        Eh144_5.InitialiseState(base_state, personalizationString); \\\r\n    } else if (n == 192 && k == 7) {         \\\r\n        Eh192_7.InitialiseState(base_state, personalizationString); \\\r\n    } else if (n == 96 && k == 5) {          \\\r\n        Eh96_5.InitialiseState(base_state, personalizationString);  \\\r\n    } else if (n == 96 && k == 3) {          \\\r\n        Eh96_3.InitialiseState(base_state, personalizationString);  \\\r\n    } else if (n == 48 && k == 5) {          \\\r\n        Eh48_5.InitialiseState(base_state, personalizationString);  \\\r\n    } else {                                 \\\r\n        throw std::invalid_argument(\"Unsupported Equihash parameters\"); \\\r\n    }\r\n\r\n#ifdef ENABLE_MINING\r\ninline bool EhBasicSolve(unsigned int n, unsigned int k, const eh_HashState& base_state,\r\n                    const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                    const std::function<bool(EhSolverCancelCheck)> cancelled)\r\n{\r\n    if (n == 200 && k == 9) {\r\n        return Eh200_9.BasicSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 125 && k == 4) {\r\n        return Eh125_4.BasicSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 144 && k == 5) {\r\n        return Eh144_5.BasicSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 192 && k == 7) {\r\n        return Eh192_7.BasicSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 96 && k == 5) {\r\n        return Eh96_5.BasicSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 96 && k == 3) {\r\n        return Eh96_3.BasicSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 48 && k == 5) {\r\n        return Eh48_5.BasicSolve(base_state, validBlock, cancelled);\r\n    } else {\r\n        throw std::invalid_argument(\"Unsupported Equihash parameters\");\r\n    }\r\n}\r\n\r\ninline bool EhBasicSolveUncancellable(unsigned int n, unsigned int k, const eh_HashState& base_state,\r\n                    const std::function<bool(std::vector<unsigned char>)> validBlock)\r\n{\r\n    return EhBasicSolve(n, k, base_state, validBlock,\r\n                        [](EhSolverCancelCheck pos) { return false; });\r\n}\r\n\r\ninline bool EhOptimisedSolve(unsigned int n, unsigned int k, const eh_HashState& base_state,\r\n                    const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                    const std::function<bool(EhSolverCancelCheck)> cancelled)\r\n{\r\n    if (n == 200 && k == 9) {\r\n        return Eh200_9.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 125 && k == 4) {\r\n        return Eh125_4.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 144 && k == 5) {\r\n        return Eh144_5.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 192 && k == 7) {\r\n        return Eh192_7.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 96 && k == 5) {\r\n        return Eh96_5.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 96 && k == 3) {\r\n        return Eh96_3.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else if (n == 48 && k == 5) {\r\n        return Eh48_5.OptimisedSolve(base_state, validBlock, cancelled);\r\n    } else {\r\n        throw std::invalid_argument(\"Unsupported Equihash parameters\");\r\n    }\r\n}\r\n\r\ninline bool EhOptimisedSolveUncancellable(unsigned int n, unsigned int k, const eh_HashState& base_state,\r\n                    const std::function<bool(std::vector<unsigned char>)> validBlock)\r\n{\r\n    return EhOptimisedSolve(n, k, base_state, validBlock,\r\n                            [](EhSolverCancelCheck pos) { return false; });\r\n}\r\n#endif // ENABLE_MINING\r\n\r\n#define EhIsValidSolution(n, k, base_state, soln, ret)   \\\r\n    if (n == 200 && k == 9) {                    \t\t \\\r\n        ret = Eh200_9.IsValidSolution(base_state, soln); \\\r\n    } else if (n == 125 && k == 4) {                     \\\r\n        ret = Eh125_4.IsValidSolution(base_state, soln); \\\r\n    } else if (n == 144 && k == 5) {                     \\\r\n        ret = Eh144_5.IsValidSolution(base_state, soln); \\\r\n    } else if (n == 192 && k == 7) {                     \\\r\n        ret = Eh192_7.IsValidSolution(base_state, soln); \\\r\n    } else if (n == 96 && k == 5) {                      \\\r\n        ret = Eh96_5.IsValidSolution(base_state, soln);  \\\r\n    } else if (n == 96 && k == 3) {                      \\\r\n        ret = Eh96_3.IsValidSolution(base_state, soln);  \\\r\n    } else if (n == 48 && k == 5) {                      \\\r\n        ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n        else if (n == 48 && k == 5) {                      \\\r\n        ret = Eh48_5.IsValidSolution(base_state, soln);  \\\r\n    } else {                                             \\\r\n        throw std::invalid_argument(\"Unsupported Equihash parameters\"); \\\r\n    }\r\n\r\n#endif // BITCOIN_EQUIHASH_H\r\n"
        }
    ]
}