{
    "sourceFile": "crypto/equihash.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1667747112283,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1667747112283,
            "name": "Commit-0",
            "content": "// Copyright (c) 2016 Jack Grigg\r\n// Copyright (c) 2016 The Zcash developers\r\n// Copyright (c) 2017-2018 The LitecoinZ developers\r\n// Copyright (c) 2017-2018 The BitcoinZ developers\r\n// Copyright (c) 2018 The s-nomp developers\r\n// Distributed under the MIT software license, see the accompanying\r\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n\r\n// Implementation of the Equihash Proof-of-Work algorithm.\r\n//\r\n// Reference\r\n// =========\r\n// Alex Biryukov and Dmitry Khovratovich\r\n// Equihash: Asymmetric Proof-of-Work Based on the Generalized Birthday Problem\r\n// NDSS â€™16, 21-24 February 2016, San Diego, CA, USA\r\n// https://www.internetsociety.org/sites/default/files/blogs-media/equihash-asymmetric-proof-of-work-based-generalized-birthday-problem.pdf\r\n\r\n#if defined(HAVE_CONFIG_H)\r\n#include \"config/bitcoin-config.h\"\r\n#endif\r\n\r\n#include \"crypto/common.h\"\r\n#include \"crypto/equihash.h\"\r\n#include \"../util.h\"\r\n\r\n#include <algorithm>\r\n#include <iostream>\r\n#include <stdexcept>\r\n\r\n#include <boost/optional.hpp>\r\n\r\nEhSolverCancelledException solver_cancelled;\r\n\r\ntemplate<unsigned int N, unsigned int K>\r\nint Equihash<N,K>::InitialiseState(eh_HashState& base_state, const char* personalizationString)\r\n{\r\n    uint32_t le_N = htole32(N);\r\n    uint32_t le_K = htole32(K);\r\n    unsigned char personalization[crypto_generichash_blake2b_PERSONALBYTES] = {};\r\n    memcpy(personalization, personalizationString, 8);\r\n    memcpy(personalization+8,  &le_N, 4);\r\n    memcpy(personalization+12, &le_K, 4);\r\n    return crypto_generichash_blake2b_init_salt_personal(&base_state,\r\n                                                         NULL, 0, // No key.\r\n                                                         (512/N)*((N+7)/8),\r\n                                                         NULL,    // No salt.\r\n                                                         personalization);\r\n}\r\n\r\nvoid GenerateHash(const eh_HashState& base_state, eh_index g,\r\n                  unsigned char* hash, size_t hLen, bool twist)\r\n{\r\n   if (!twist) {\t\r\n\t    eh_HashState state;\r\n\t    state = base_state;\r\n\t    eh_index lei = htole32(g);\r\n\t    crypto_generichash_blake2b_update(&state, (const unsigned char*) &lei,\r\n\t\t                              sizeof(eh_index));\r\n\t    crypto_generichash_blake2b_final(&state, hash, hLen);\r\n    } else {\r\n\t    uint32_t myHash[16] = {0};\r\n\t    uint32_t startIndex = g & 0xFFFFFFF0;\r\n\r\n\t    for (uint32_t g2 = startIndex; g2 <= g; g2++) {\r\n\t\t    uint32_t tmpHash[16] = {0};\r\n\r\n\t\t    eh_HashState state;\t\r\n\t\t    state = base_state;\r\n\t\t    eh_index lei = htole32(g2);\r\n\t\t    crypto_generichash_blake2b_update(&state, (const unsigned char*) &lei,\r\n\t\t\t\t                      sizeof(eh_index));\r\n\r\n\t\t    crypto_generichash_blake2b_final(&state, (unsigned char*)&tmpHash[0], hLen);\r\n\r\n\t\t    for (uint32_t idx = 0; idx < 16; idx++) myHash[idx] += tmpHash[idx];\r\n\t    }\r\n\r\n\t    uint8_t * hashBytes = (uint8_t *) &myHash[0]; \r\n\r\n\t    for (uint32_t i=15; i<hLen; i+=16) hashBytes[i] &= 0xF8;\t\r\n\r\n\t    memcpy(hash, &myHash[0], hLen);\t\r\n\r\n\r\n    }\r\n}\r\n\r\n\r\nvoid ExpandArray(const unsigned char* in, size_t in_len,\r\n                 unsigned char* out, size_t out_len,\r\n                 size_t bit_len, size_t byte_pad)\r\n{\r\n    assert(bit_len >= 8);\r\n    assert(8*sizeof(uint32_t) >= bit_len);\r\n\r\n    size_t out_width { (bit_len+7)/8 + byte_pad };\r\n    assert(out_len == 8*out_width*in_len/bit_len);\r\n\r\n    uint32_t bit_len_mask { ((uint32_t)1 << bit_len) - 1 };\r\n\r\n    // The acc_bits least-significant bits of acc_value represent a bit sequence\r\n    // in big-endian order.\r\n    size_t acc_bits = 0;\r\n    uint32_t acc_value = 0;\r\n\r\n    size_t j = 0;\r\n    for (size_t i = 0; i < in_len; i++) {\r\n        acc_value = (acc_value << 8) | in[i];\r\n        acc_bits += 8;\r\n\r\n        // When we have bit_len or more bits in the accumulator, write the next\r\n        // output element.\r\n        if (acc_bits >= bit_len) {\r\n            acc_bits -= bit_len;\r\n            for (size_t x = 0; x < byte_pad; x++) {\r\n                out[j+x] = 0;\r\n            }\r\n            for (size_t x = byte_pad; x < out_width; x++) {\r\n                out[j+x] = (\r\n                    // Big-endian\r\n                    acc_value >> (acc_bits+(8*(out_width-x-1)))\r\n                ) & (\r\n                    // Apply bit_len_mask across byte boundaries\r\n                    (bit_len_mask >> (8*(out_width-x-1))) & 0xFF\r\n                );\r\n            }\r\n            j += out_width;\r\n        }\r\n    }\r\n}\r\n\r\nvoid CompressArray(const unsigned char* in, size_t in_len,\r\n                   unsigned char* out, size_t out_len,\r\n                   size_t bit_len, size_t byte_pad)\r\n{\r\n    assert(bit_len >= 8);\r\n    assert(8*sizeof(uint32_t) >= bit_len);\r\n\r\n    size_t in_width { (bit_len+7)/8 + byte_pad };\r\n    assert(out_len == bit_len*in_len/(8*in_width));\r\n\r\n    uint32_t bit_len_mask { ((uint32_t)1 << bit_len) - 1 };\r\n\r\n    // The acc_bits least-significant bits of acc_value represent a bit sequence\r\n    // in big-endian order.\r\n    size_t acc_bits = 0;\r\n    uint32_t acc_value = 0;\r\n\r\n    size_t j = 0;\r\n    for (size_t i = 0; i < out_len; i++) {\r\n        // When we have fewer than 8 bits left in the accumulator, read the next\r\n        // input element.\r\n        if (acc_bits < 8) {\r\n            acc_value = acc_value << bit_len;\r\n            for (size_t x = byte_pad; x < in_width; x++) {\r\n                acc_value = acc_value | (\r\n                    (\r\n                        // Apply bit_len_mask across byte boundaries\r\n                        in[j+x] & ((bit_len_mask >> (8*(in_width-x-1))) & 0xFF)\r\n                    ) << (8*(in_width-x-1))); // Big-endian\r\n            }\r\n            j += in_width;\r\n            acc_bits += bit_len;\r\n        }\r\n\r\n        acc_bits -= 8;\r\n        out[i] = (acc_value >> acc_bits) & 0xFF;\r\n    }\r\n}\r\n\r\n// Big-endian so that lexicographic array comparison is equivalent to integer\r\n// comparison\r\nvoid EhIndexToArray(const eh_index i, unsigned char* array)\r\n{\r\n    BOOST_STATIC_ASSERT(sizeof(eh_index) == 4);\r\n    eh_index bei = htobe32(i);\r\n    memcpy(array, &bei, sizeof(eh_index));\r\n}\r\n\r\n// Big-endian so that lexicographic array comparison is equivalent to integer\r\n// comparison\r\neh_index ArrayToEhIndex(const unsigned char* array)\r\n{\r\n    BOOST_STATIC_ASSERT(sizeof(eh_index) == 4);\r\n    eh_index bei;\r\n    memcpy(&bei, array, sizeof(eh_index));\r\n    return be32toh(bei);\r\n}\r\n\r\neh_trunc TruncateIndex(const eh_index i, const unsigned int ilen)\r\n{\r\n    // Truncate to 8 bits\r\n    BOOST_STATIC_ASSERT(sizeof(eh_trunc) == 1);\r\n    return (i >> (ilen - 8)) & 0xff;\r\n}\r\n\r\neh_index UntruncateIndex(const eh_trunc t, const eh_index r, const unsigned int ilen)\r\n{\r\n    eh_index i{t};\r\n    return (i << (ilen - 8)) | r;\r\n}\r\n\r\nstd::vector<eh_index> GetIndicesFromMinimal(std::vector<unsigned char> minimal,\r\n                                            size_t cBitLen)\r\n{\r\n    assert(((cBitLen+1)+7)/8 <= sizeof(eh_index));\r\n    size_t lenIndices { 8*sizeof(eh_index)*minimal.size()/(cBitLen+1) };\r\n    size_t bytePad { sizeof(eh_index) - ((cBitLen+1)+7)/8 };\r\n    std::vector<unsigned char> array(lenIndices);\r\n    ExpandArray(minimal.data(), minimal.size(),\r\n                array.data(), lenIndices, cBitLen+1, bytePad);\r\n    std::vector<eh_index> ret;\r\n    for (int i = 0; i < lenIndices; i += sizeof(eh_index)) {\r\n        ret.push_back(ArrayToEhIndex(array.data()+i));\r\n    }\r\n    return ret;\r\n}\r\n\r\nstd::vector<unsigned char> GetMinimalFromIndices(std::vector<eh_index> indices,\r\n                                                 size_t cBitLen)\r\n{\r\n    assert(((cBitLen+1)+7)/8 <= sizeof(eh_index));\r\n    size_t lenIndices { indices.size()*sizeof(eh_index) };\r\n    size_t minLen { (cBitLen+1)*lenIndices/(8*sizeof(eh_index)) };\r\n    size_t bytePad { sizeof(eh_index) - ((cBitLen+1)+7)/8 };\r\n    std::vector<unsigned char> array(lenIndices);\r\n    for (int i = 0; i < indices.size(); i++) {\r\n        EhIndexToArray(indices[i], array.data()+(i*sizeof(eh_index)));\r\n    }\r\n    std::vector<unsigned char> ret(minLen);\r\n    CompressArray(array.data(), lenIndices,\r\n                  ret.data(), minLen, cBitLen+1, bytePad);\r\n    return ret;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nStepRow<WIDTH>::StepRow(const unsigned char* hashIn, size_t hInLen,\r\n                        size_t hLen, size_t cBitLen)\r\n{\r\n    assert(hLen <= WIDTH);\r\n    ExpandArray(hashIn, hInLen, hash, hLen, cBitLen);\r\n}\r\n\r\ntemplate<size_t WIDTH> template<size_t W>\r\nStepRow<WIDTH>::StepRow(const StepRow<W>& a)\r\n{\r\n    BOOST_STATIC_ASSERT(W <= WIDTH);\r\n    std::copy(a.hash, a.hash+W, hash);\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nFullStepRow<WIDTH>::FullStepRow(const unsigned char* hashIn, size_t hInLen,\r\n                                size_t hLen, size_t cBitLen, eh_index i) :\r\n        StepRow<WIDTH> {hashIn, hInLen, hLen, cBitLen}\r\n{\r\n    EhIndexToArray(i, hash+hLen);\r\n}\r\n\r\ntemplate<size_t WIDTH> template<size_t W>\r\nFullStepRow<WIDTH>::FullStepRow(const FullStepRow<W>& a, const FullStepRow<W>& b, size_t len, size_t lenIndices, int trim) :\r\n        StepRow<WIDTH> {a}\r\n{\r\n    assert(len+lenIndices <= W);\r\n    assert(len-trim+(2*lenIndices) <= WIDTH);\r\n    for (int i = trim; i < len; i++)\r\n        hash[i-trim] = a.hash[i] ^ b.hash[i];\r\n    if (a.IndicesBefore(b, len, lenIndices)) {\r\n        std::copy(a.hash+len, a.hash+len+lenIndices, hash+len-trim);\r\n        std::copy(b.hash+len, b.hash+len+lenIndices, hash+len-trim+lenIndices);\r\n    } else {\r\n        std::copy(b.hash+len, b.hash+len+lenIndices, hash+len-trim);\r\n        std::copy(a.hash+len, a.hash+len+lenIndices, hash+len-trim+lenIndices);\r\n    }\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nFullStepRow<WIDTH>& FullStepRow<WIDTH>::operator=(const FullStepRow<WIDTH>& a)\r\n{\r\n    std::copy(a.hash, a.hash+WIDTH, hash);\r\n    return *this;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nbool StepRow<WIDTH>::IsZero(size_t len)\r\n{\r\n    // This doesn't need to be constant time.\r\n    for (int i = 0; i < len; i++) {\r\n        if (hash[i] != 0)\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nstd::vector<unsigned char> FullStepRow<WIDTH>::GetIndices(size_t len, size_t lenIndices,\r\n                                                          size_t cBitLen) const\r\n{\r\n    assert(((cBitLen+1)+7)/8 <= sizeof(eh_index));\r\n    size_t minLen { (cBitLen+1)*lenIndices/(8*sizeof(eh_index)) };\r\n    size_t bytePad { sizeof(eh_index) - ((cBitLen+1)+7)/8 };\r\n    std::vector<unsigned char> ret(minLen);\r\n    CompressArray(hash+len, lenIndices, ret.data(), minLen, cBitLen+1, bytePad);\r\n    return ret;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nbool HasCollision(StepRow<WIDTH>& a, StepRow<WIDTH>& b, int l)\r\n{\r\n    // This doesn't need to be constant time.\r\n    for (int j = 0; j < l; j++) {\r\n        if (a.hash[j] != b.hash[j])\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nTruncatedStepRow<WIDTH>::TruncatedStepRow(const unsigned char* hashIn, size_t hInLen,\r\n                                          size_t hLen, size_t cBitLen,\r\n                                          eh_index i, unsigned int ilen) :\r\n        StepRow<WIDTH> {hashIn, hInLen, hLen, cBitLen}\r\n{\r\n    hash[hLen] = TruncateIndex(i, ilen);\r\n}\r\n\r\ntemplate<size_t WIDTH> template<size_t W>\r\nTruncatedStepRow<WIDTH>::TruncatedStepRow(const TruncatedStepRow<W>& a, const TruncatedStepRow<W>& b, size_t len, size_t lenIndices, int trim) :\r\n        StepRow<WIDTH> {a}\r\n{\r\n    assert(len+lenIndices <= W);\r\n    assert(len-trim+(2*lenIndices) <= WIDTH);\r\n    for (int i = trim; i < len; i++)\r\n        hash[i-trim] = a.hash[i] ^ b.hash[i];\r\n    if (a.IndicesBefore(b, len, lenIndices)) {\r\n        std::copy(a.hash+len, a.hash+len+lenIndices, hash+len-trim);\r\n        std::copy(b.hash+len, b.hash+len+lenIndices, hash+len-trim+lenIndices);\r\n    } else {\r\n        std::copy(b.hash+len, b.hash+len+lenIndices, hash+len-trim);\r\n        std::copy(a.hash+len, a.hash+len+lenIndices, hash+len-trim+lenIndices);\r\n    }\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nTruncatedStepRow<WIDTH>& TruncatedStepRow<WIDTH>::operator=(const TruncatedStepRow<WIDTH>& a)\r\n{\r\n    std::copy(a.hash, a.hash+WIDTH, hash);\r\n    return *this;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nstd::shared_ptr<eh_trunc> TruncatedStepRow<WIDTH>::GetTruncatedIndices(size_t len, size_t lenIndices) const\r\n{\r\n    std::shared_ptr<eh_trunc> p (new eh_trunc[lenIndices], std::default_delete<eh_trunc[]>());\r\n    std::copy(hash+len, hash+len+lenIndices, p.get());\r\n    return p;\r\n}\r\n\r\n#ifdef ENABLE_MINING\r\ntemplate<unsigned int N, unsigned int K>\r\nbool Equihash<N,K>::BasicSolve(const eh_HashState& base_state,\r\n                               const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                               const std::function<bool(EhSolverCancelCheck)> cancelled)\r\n{\r\n    eh_index init_size { 1 << (CollisionBitLength + 1) };\r\n\r\n    // 1) Generate first list\r\n    LogPrint(\"pow\", \"Generating first list\\n\");\r\n    size_t hashLen = HashLength;\r\n    size_t lenIndices = sizeof(eh_index);\r\n    std::vector<FullStepRow<FullWidth>> X;\r\n    X.reserve(init_size);\r\n\r\n    bool twist = ((N == 125) && (K == 4));\r\n\r\n    GenerateHash(base_state, g, tmpHash, HashOutput, twist);\r\n    for (eh_index g = 0; X.size() < init_size; g++) {\r\n        GenerateHash(base_state, g, tmpHash, HashOutput);\r\n        for (eh_index i = 0; i < IndicesPerHashOutput && X.size() < init_size; i++) {\r\n            X.emplace_back(tmpHash+(i*((N+7)/8)), ((N+7)/8), HashLength,\r\n                           CollisionBitLength, (g*IndicesPerHashOutput)+i);\r\n        }\r\n        if (cancelled(ListGeneration)) throw solver_cancelled;\r\n    }\r\n\r\n    // 3) Repeat step 2 until 2n/(k+1) bits remain\r\n    for (int r = 1; r < K && X.size() > 0; r++) {\r\n        LogPrint(\"pow\", \"Round %d:\\n\", r);\r\n        // 2a) Sort the list\r\n        LogPrint(\"pow\", \"- Sorting list\\n\");\r\n        std::sort(X.begin(), X.end(), CompareSR(CollisionByteLength));\r\n        if (cancelled(ListSorting)) throw solver_cancelled;\r\n\r\n        LogPrint(\"pow\", \"- Finding collisions\\n\");\r\n        int i = 0;\r\n        int posFree = 0;\r\n        std::vector<FullStepRow<FullWidth>> Xc;\r\n        while (i < X.size() - 1) {\r\n            // 2b) Find next set of unordered pairs with collisions on the next n/(k+1) bits\r\n            int j = 1;\r\n            while (i+j < X.size() &&\r\n                    HasCollision(X[i], X[i+j], CollisionByteLength)) {\r\n                j++;\r\n            }\r\n\r\n            // 2c) Calculate tuples (X_i ^ X_j, (i, j))\r\n            for (int l = 0; l < j - 1; l++) {\r\n                for (int m = l + 1; m < j; m++) {\r\n                    if (DistinctIndices(X[i+l], X[i+m], hashLen, lenIndices)) {\r\n                        Xc.emplace_back(X[i+l], X[i+m], hashLen, lenIndices, CollisionByteLength);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 2d) Store tuples on the table in-place if possible\r\n            while (posFree < i+j && Xc.size() > 0) {\r\n                X[posFree++] = Xc.back();\r\n                Xc.pop_back();\r\n            }\r\n\r\n            i += j;\r\n            if (cancelled(ListColliding)) throw solver_cancelled;\r\n        }\r\n\r\n        // 2e) Handle edge case where final table entry has no collision\r\n        while (posFree < X.size() && Xc.size() > 0) {\r\n            X[posFree++] = Xc.back();\r\n            Xc.pop_back();\r\n        }\r\n\r\n        if (Xc.size() > 0) {\r\n            // 2f) Add overflow to end of table\r\n            X.insert(X.end(), Xc.begin(), Xc.end());\r\n        } else if (posFree < X.size()) {\r\n            // 2g) Remove empty space at the end\r\n            X.erase(X.begin()+posFree, X.end());\r\n            X.shrink_to_fit();\r\n        }\r\n\r\n        hashLen -= CollisionByteLength;\r\n        lenIndices *= 2;\r\n        if (cancelled(RoundEnd)) throw solver_cancelled;\r\n    }\r\n\r\n    // k+1) Find a collision on last 2n(k+1) bits\r\n    LogPrint(\"pow\", \"Final round:\\n\");\r\n    if (X.size() > 1) {\r\n        LogPrint(\"pow\", \"- Sorting list\\n\");\r\n        std::sort(X.begin(), X.end(), CompareSR(hashLen));\r\n        if (cancelled(FinalSorting)) throw solver_cancelled;\r\n        LogPrint(\"pow\", \"- Finding collisions\\n\");\r\n        int i = 0;\r\n        while (i < X.size() - 1) {\r\n            int j = 1;\r\n            while (i+j < X.size() &&\r\n                    HasCollision(X[i], X[i+j], hashLen)) {\r\n                j++;\r\n            }\r\n\r\n            for (int l = 0; l < j - 1; l++) {\r\n                for (int m = l + 1; m < j; m++) {\r\n                    FullStepRow<FinalFullWidth> res(X[i+l], X[i+m], hashLen, lenIndices, 0);\r\n                    if (DistinctIndices(X[i+l], X[i+m], hashLen, lenIndices)) {\r\n                        auto soln = res.GetIndices(hashLen, 2*lenIndices, CollisionBitLength);\r\n                        assert(soln.size() == equihash_solution_size(N, K));\r\n                        if (validBlock(soln)) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            i += j;\r\n            if (cancelled(FinalColliding)) throw solver_cancelled;\r\n        }\r\n    } else\r\n        LogPrint(\"pow\", \"- List is empty\\n\");\r\n\r\n    return false;\r\n}\r\n\r\ntemplate<size_t WIDTH>\r\nvoid CollideBranches(std::vector<FullStepRow<WIDTH>>& X, const size_t hlen, const size_t lenIndices, const unsigned int clen, const unsigned int ilen, const eh_trunc lt, const eh_trunc rt)\r\n{\r\n    int i = 0;\r\n    int posFree = 0;\r\n    std::vector<FullStepRow<WIDTH>> Xc;\r\n    while (i < X.size() - 1) {\r\n        // 2b) Find next set of unordered pairs with collisions on the next n/(k+1) bits\r\n        int j = 1;\r\n        while (i+j < X.size() &&\r\n                HasCollision(X[i], X[i+j], clen)) {\r\n            j++;\r\n        }\r\n\r\n        // 2c) Calculate tuples (X_i ^ X_j, (i, j))\r\n        for (int l = 0; l < j - 1; l++) {\r\n            for (int m = l + 1; m < j; m++) {\r\n                if (DistinctIndices(X[i+l], X[i+m], hlen, lenIndices)) {\r\n                    if (IsValidBranch(X[i+l], hlen, ilen, lt) && IsValidBranch(X[i+m], hlen, ilen, rt)) {\r\n                        Xc.emplace_back(X[i+l], X[i+m], hlen, lenIndices, clen);\r\n                    } else if (IsValidBranch(X[i+m], hlen, ilen, lt) && IsValidBranch(X[i+l], hlen, ilen, rt)) {\r\n                        Xc.emplace_back(X[i+m], X[i+l], hlen, lenIndices, clen);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // 2d) Store tuples on the table in-place if possible\r\n        while (posFree < i+j && Xc.size() > 0) {\r\n            X[posFree++] = Xc.back();\r\n            Xc.pop_back();\r\n        }\r\n\r\n        i += j;\r\n    }\r\n\r\n    // 2e) Handle edge case where final table entry has no collision\r\n    while (posFree < X.size() && Xc.size() > 0) {\r\n        X[posFree++] = Xc.back();\r\n        Xc.pop_back();\r\n    }\r\n\r\n    if (Xc.size() > 0) {\r\n        // 2f) Add overflow to end of table\r\n        X.insert(X.end(), Xc.begin(), Xc.end());\r\n    } else if (posFree < X.size()) {\r\n        // 2g) Remove empty space at the end\r\n        X.erase(X.begin()+posFree, X.end());\r\n        X.shrink_to_fit();\r\n    }\r\n}\r\n\r\ntemplate<unsigned int N, unsigned int K>\r\nbool Equihash<N,K>::OptimisedSolve(const eh_HashState& base_state,\r\n                                   const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                   const std::function<bool(EhSolverCancelCheck)> cancelled)\r\n{\r\n    eh_index init_size { 1 << (CollisionBitLength + 1) };\r\n    eh_index recreate_size { UntruncateIndex(1, 0, CollisionBitLength + 1) };\r\n\r\n    // First run the algorithm with truncated indices\r\n\r\n    bool twist = ((N == 125) && (K ==4));\r\n\r\n    const eh_index soln_size { 1 << K };\r\n    std::vector<std::shared_ptr<eh_trunc>> partialSolns;\r\n    int invalidCount = 0;\r\n    {\r\n\r\n        // 1) Generate first list\r\n        LogPrint(\"pow\", \"Generating first list\\n\");\r\n        size_t hashLen = HashLength;\r\n        size_t lenIndices = sizeof(eh_trunc);\r\n        std::vector<TruncatedStepRow<TruncatedWidth>> Xt;\r\n        Xt.reserve(init_size);\r\n        unsigned char tmpHash[HashOutput];\r\n        for (eh_index g = 0; Xt.size() < init_size; g++) {\r\n            GenerateHash(base_state, g, tmpHash, HashOutput, twist);\r\n            for (eh_index i = 0; i < IndicesPerHashOutput && Xt.size() < init_size; i++) {\r\n                Xt.emplace_back(tmpHash+(i*((N+7)/8)), ((N+7)/8), HashLength, CollisionBitLength,\r\n                                (g*IndicesPerHashOutput)+i, CollisionBitLength + 1);\r\n            }\r\n            if (cancelled(ListGeneration)) throw solver_cancelled;\r\n        }\r\n\r\n        // 3) Repeat step 2 until 2n/(k+1) bits remain\r\n        for (int r = 1; r < K && Xt.size() > 0; r++) {\r\n            LogPrint(\"pow\", \"Round %d:\\n\", r);\r\n            // 2a) Sort the list\r\n            LogPrint(\"pow\", \"- Sorting list\\n\");\r\n            std::sort(Xt.begin(), Xt.end(), CompareSR(CollisionByteLength));\r\n            if (cancelled(ListSorting)) throw solver_cancelled;\r\n\r\n            LogPrint(\"pow\", \"- Finding collisions\\n\");\r\n            int i = 0;\r\n            int posFree = 0;\r\n            std::vector<TruncatedStepRow<TruncatedWidth>> Xc;\r\n            while (i < Xt.size() - 1) {\r\n                // 2b) Find next set of unordered pairs with collisions on the next n/(k+1) bits\r\n                int j = 1;\r\n                while (i+j < Xt.size() &&\r\n                        HasCollision(Xt[i], Xt[i+j], CollisionByteLength)) {\r\n                    j++;\r\n                }\r\n\r\n                // 2c) Calculate tuples (X_i ^ X_j, (i, j))\r\n                bool checking_for_zero = (i == 0 && Xt[0].IsZero(hashLen));\r\n                for (int l = 0; l < j - 1; l++) {\r\n                    for (int m = l + 1; m < j; m++) {\r\n                        // We truncated, so don't check for distinct indices here\r\n                        TruncatedStepRow<TruncatedWidth> Xi {Xt[i+l], Xt[i+m],\r\n                                                             hashLen, lenIndices,\r\n                                                             CollisionByteLength};\r\n                        if (!(Xi.IsZero(hashLen-CollisionByteLength) &&\r\n                              IsProbablyDuplicate<soln_size>(Xi.GetTruncatedIndices(hashLen-CollisionByteLength, 2*lenIndices),\r\n                                                             2*lenIndices))) {\r\n                            Xc.emplace_back(Xi);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // 2d) Store tuples on the table in-place if possible\r\n                while (posFree < i+j && Xc.size() > 0) {\r\n                    Xt[posFree++] = Xc.back();\r\n                    Xc.pop_back();\r\n                }\r\n\r\n                i += j;\r\n                if (cancelled(ListColliding)) throw solver_cancelled;\r\n            }\r\n\r\n            // 2e) Handle edge case where final table entry has no collision\r\n            while (posFree < Xt.size() && Xc.size() > 0) {\r\n                Xt[posFree++] = Xc.back();\r\n                Xc.pop_back();\r\n            }\r\n\r\n            if (Xc.size() > 0) {\r\n                // 2f) Add overflow to end of table\r\n                Xt.insert(Xt.end(), Xc.begin(), Xc.end());\r\n            } else if (posFree < Xt.size()) {\r\n                // 2g) Remove empty space at the end\r\n                Xt.erase(Xt.begin()+posFree, Xt.end());\r\n                Xt.shrink_to_fit();\r\n            }\r\n\r\n            hashLen -= CollisionByteLength;\r\n            lenIndices *= 2;\r\n            if (cancelled(RoundEnd)) throw solver_cancelled;\r\n        }\r\n\r\n        // k+1) Find a collision on last 2n(k+1) bits\r\n        LogPrint(\"pow\", \"Final round:\\n\");\r\n        if (Xt.size() > 1) {\r\n            LogPrint(\"pow\", \"- Sorting list\\n\");\r\n            std::sort(Xt.begin(), Xt.end(), CompareSR(hashLen));\r\n            if (cancelled(FinalSorting)) throw solver_cancelled;\r\n            LogPrint(\"pow\", \"- Finding collisions\\n\");\r\n            int i = 0;\r\n            while (i < Xt.size() - 1) {\r\n                int j = 1;\r\n                while (i+j < Xt.size() &&\r\n                        HasCollision(Xt[i], Xt[i+j], hashLen)) {\r\n                    j++;\r\n                }\r\n\r\n                for (int l = 0; l < j - 1; l++) {\r\n                    for (int m = l + 1; m < j; m++) {\r\n                        TruncatedStepRow<FinalTruncatedWidth> res(Xt[i+l], Xt[i+m],\r\n                                                                  hashLen, lenIndices, 0);\r\n                        auto soln = res.GetTruncatedIndices(hashLen, 2*lenIndices);\r\n                        if (!IsProbablyDuplicate<soln_size>(soln, 2*lenIndices)) {\r\n                            partialSolns.push_back(soln);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                i += j;\r\n                if (cancelled(FinalColliding)) throw solver_cancelled;\r\n            }\r\n        } else\r\n            LogPrint(\"pow\", \"- List is empty\\n\");\r\n\r\n    } // Ensure Xt goes out of scope and is destroyed\r\n\r\n    LogPrint(\"pow\", \"Found %d partial solutions\\n\", partialSolns.size());\r\n\r\n    // Now for each solution run the algorithm again to recreate the indices\r\n    LogPrint(\"pow\", \"Culling solutions\\n\");\r\n    for (std::shared_ptr<eh_trunc> partialSoln : partialSolns) {\r\n        std::set<std::vector<unsigned char>> solns;\r\n        size_t hashLen;\r\n        size_t lenIndices;\r\n        unsigned char tmpHash[HashOutput];\r\n        std::vector<boost::optional<std::vector<FullStepRow<FinalFullWidth>>>> X;\r\n        X.reserve(K+1);\r\n\r\n        // 3) Repeat steps 1 and 2 for each partial index\r\n        for (eh_index i = 0; i < soln_size; i++) {\r\n            // 1) Generate first list of possibilities\r\n            std::vector<FullStepRow<FinalFullWidth>> icv;\r\n            icv.reserve(recreate_size);\r\n            for (eh_index j = 0; j < recreate_size; j++) {\r\n                eh_index newIndex { UntruncateIndex(partialSoln.get()[i], j, CollisionBitLength + 1) };\r\n                if (j == 0 || newIndex % IndicesPerHashOutput == 0) {\r\n                    GenerateHash(base_state, newIndex/IndicesPerHashOutput,\r\n                                 tmpHash, HashOutput, twist);\r\n                }\r\n                icv.emplace_back(tmpHash+((newIndex % IndicesPerHashOutput) * ((N+7)/8)),\r\n                                 ((N+7)/8), HashLength, CollisionBitLength, newIndex);\r\n                if (cancelled(PartialGeneration)) throw solver_cancelled;\r\n            }\r\n            boost::optional<std::vector<FullStepRow<FinalFullWidth>>> ic = icv;\r\n\r\n            // 2a) For each pair of lists:\r\n            hashLen = HashLength;\r\n            lenIndices = sizeof(eh_index);\r\n            size_t rti = i;\r\n            for (size_t r = 0; r <= K; r++) {\r\n                // 2b) Until we are at the top of a subtree:\r\n                if (r < X.size()) {\r\n                    if (X[r]) {\r\n                        // 2c) Merge the lists\r\n                        ic->reserve(ic->size() + X[r]->size());\r\n                        ic->insert(ic->end(), X[r]->begin(), X[r]->end());\r\n                        std::sort(ic->begin(), ic->end(), CompareSR(hashLen));\r\n                        if (cancelled(PartialSorting)) throw solver_cancelled;\r\n                        size_t lti = rti-(1<<r);\r\n                        CollideBranches(*ic, hashLen, lenIndices,\r\n                                        CollisionByteLength,\r\n                                        CollisionBitLength + 1,\r\n                                        partialSoln.get()[lti], partialSoln.get()[rti]);\r\n\r\n                        // 2d) Check if this has become an invalid solution\r\n                        if (ic->size() == 0)\r\n                            goto invalidsolution;\r\n\r\n                        X[r] = boost::none;\r\n                        hashLen -= CollisionByteLength;\r\n                        lenIndices *= 2;\r\n                        rti = lti;\r\n                    } else {\r\n                        X[r] = *ic;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    X.push_back(ic);\r\n                    break;\r\n                }\r\n                if (cancelled(PartialSubtreeEnd)) throw solver_cancelled;\r\n            }\r\n            if (cancelled(PartialIndexEnd)) throw solver_cancelled;\r\n        }\r\n\r\n        // We are at the top of the tree\r\n        assert(X.size() == K+1);\r\n        for (FullStepRow<FinalFullWidth> row : *X[K]) {\r\n            auto soln = row.GetIndices(hashLen, lenIndices, CollisionBitLength);\r\n            assert(soln.size() == equihash_solution_size(N, K));\r\n            solns.insert(soln);\r\n        }\r\n        for (auto soln : solns) {\r\n            if (validBlock(soln))\r\n                return true;\r\n        }\r\n        if (cancelled(PartialEnd)) throw solver_cancelled;\r\n        continue;\r\n\r\ninvalidsolution:\r\n        invalidCount++;\r\n    }\r\n    LogPrint(\"pow\", \"- Number of invalid solutions found: %d\\n\", invalidCount);\r\n\r\n    return false;\r\n}\r\n#endif // ENABLE_MINING\r\n\r\ntemplate<unsigned int N, unsigned int K>\r\nbool Equihash<N,K>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln)\r\n{\r\n    if (soln.size() != SolutionWidth) {\r\n        LogPrint(\"pow\", \"Invalid solution length: %d (expected %d)\\n\",\r\n                 soln.size(), SolutionWidth);\r\n        return false;\r\n    }\r\n\r\n    bool twist = ((N == 125) && (K ==4));\r\n\r\n    std::vector<FullStepRow<FinalFullWidth>> X;\r\n    X.reserve(1 << K);\r\n    unsigned char tmpHash[HashOutput];\r\n    for (eh_index i : GetIndicesFromMinimal(soln, CollisionBitLength)) {\r\n        GenerateHash(base_state, i/IndicesPerHashOutput, tmpHash, HashOutput, twist);\r\n        X.emplace_back(tmpHash+((i % IndicesPerHashOutput) * ((N+7)/8)),\r\n                       ((N+7)/8), HashLength, CollisionBitLength, i);\r\n    }\r\n\r\n    size_t hashLen = HashLength;\r\n    size_t lenIndices = sizeof(eh_index);\r\n    while (X.size() > 1) {\r\n        std::vector<FullStepRow<FinalFullWidth>> Xc;\r\n        for (int i = 0; i < X.size(); i += 2) {\r\n            if (!HasCollision(X[i], X[i+1], CollisionByteLength)) {\r\n                LogPrint(\"pow\", \"Invalid solution: invalid collision length between StepRows\\n\");\r\n                LogPrint(\"pow\", \"X[i]   = %s\\n\", X[i].GetHex(hashLen));\r\n                LogPrint(\"pow\", \"X[i+1] = %s\\n\", X[i+1].GetHex(hashLen));\r\n                return false;\r\n            }\r\n            if (X[i+1].IndicesBefore(X[i], hashLen, lenIndices)) {\r\n                LogPrint(\"pow\", \"Invalid solution: Index tree incorrectly ordered\\n\");\r\n                return false;\r\n            }\r\n            if (!DistinctIndices(X[i], X[i+1], hashLen, lenIndices)) {\r\n                LogPrint(\"pow\", \"Invalid solution: duplicate indices\\n\");\r\n                return false;\r\n            }\r\n            Xc.emplace_back(X[i], X[i+1], hashLen, lenIndices, CollisionByteLength);\r\n        }\r\n        X = Xc;\r\n        hashLen -= CollisionByteLength;\r\n        lenIndices *= 2;\r\n    }\r\n\r\n    assert(X.size() == 1);\r\n    return X[0].IsZero(hashLen);\r\n}\r\n\r\n// Explicit instantiations for Equihash<200,9>\r\ntemplate int Equihash<200,9>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<200,9>::BasicSolve(const eh_HashState& base_state,\r\n                                          const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                          const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<200,9>::OptimisedSolve(const eh_HashState& base_state,\r\n                                              const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                              const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<200,9>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n// Explicit instantiations for ZelHash - Equihash<125,4>\r\ntemplate int Equihash<125,4>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<125,4>::BasicSolve(const eh_HashState& base_state,\r\n                                          const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                          const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<125,4>::OptimisedSolve(const eh_HashState& base_state,\r\n                                              const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                              const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<125,4>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n// Explicit instantiations for Equihash<144,5>\r\ntemplate int Equihash<144,5>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<144,5>::BasicSolve(const eh_HashState& base_state,\r\n                                          const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                          const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<144,5>::OptimisedSolve(const eh_HashState& base_state,\r\n                                              const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                              const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<144,5>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n// Explicit instantiations for Equihash<192,7>\r\ntemplate int Equihash<192,7>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<192,7>::BasicSolve(const eh_HashState& base_state,\r\n                                         const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                         const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<192,7>::OptimisedSolve(const eh_HashState& base_state,\r\n                                             const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                             const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<192,7>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n// Explicit instantiations for Equihash<96,5>\r\ntemplate int Equihash<96,5>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<96,5>::BasicSolve(const eh_HashState& base_state,\r\n                                         const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                         const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<96,5>::OptimisedSolve(const eh_HashState& base_state,\r\n                                             const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                             const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<96,5>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n// Explicit instantiations for Equihash<96,3>\r\ntemplate int Equihash<96,3>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<96,3>::BasicSolve(const eh_HashState& base_state,\r\n                                         const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                         const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<96,3>::OptimisedSolve(const eh_HashState& base_state,\r\n                                             const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                             const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<96,3>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n// Explicit instantiations for Equihash<48,5>\r\ntemplate int Equihash<48,5>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<48,5>::BasicSolve(const eh_HashState& base_state,\r\n                                         const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                         const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<48,5>::OptimisedSolve(const eh_HashState& base_state,\r\n                                             const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                             const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<48,5>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n\r\n\r\n// Explicit instantiations for Equihash<184,7>\r\ntemplate int Equihash<184,7>::InitialiseState(eh_HashState& base_state, const char* personalizationString);\r\n#ifdef ENABLE_MINING\r\ntemplate bool Equihash<184,7>::BasicSolve(const eh_HashState& base_state,\r\n                                         const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                         const std::function<bool(EhSolverCancelCheck)> cancelled);\r\ntemplate bool Equihash<184,7>::OptimisedSolve(const eh_HashState& base_state,\r\n                                             const std::function<bool(std::vector<unsigned char>)> validBlock,\r\n                                             const std::function<bool(EhSolverCancelCheck)> cancelled);\r\n#endif\r\ntemplate bool Equihash<184,7>::IsValidSolution(const eh_HashState& base_state, std::vector<unsigned char> soln);\r\n"
        }
    ]
}